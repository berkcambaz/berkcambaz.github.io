import{z as H,A as R}from"./index-40a7cff9.js";function _(c,a){let s;try{s=c()}catch{return}return{getItem:i=>{var e;const v=h=>h===null?null:JSON.parse(h,a==null?void 0:a.reviver),m=(e=s.getItem(i))!=null?e:null;return m instanceof Promise?m.then(v):v(m)},setItem:(i,e)=>s.setItem(i,JSON.stringify(e,a==null?void 0:a.replacer)),removeItem:i=>s.removeItem(i)}}const I=c=>a=>{try{const s=c(a);return s instanceof Promise?s:{then(o){return I(o)(s)},catch(o){return this}}}catch(s){return{then(o){return this},catch(o){return I(o)(s)}}}},w=(c,a)=>(s,o,i)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,d)=>({...d,...r}),...a},v=!1;const m=new Set,h=new Set;let l;try{l=e.getStorage()}catch{}if(!l)return c((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...r)},o,i);const S=I(e.serialize),p=()=>{const r=e.partialize({...o()});let d;const t=S({state:r,version:e.version}).then(u=>l.setItem(e.name,u)).catch(u=>{d=u});if(d)throw d;return t},y=i.setState;i.setState=(r,d)=>{y(r,d),p()};const f=c((...r)=>{s(...r),p()},o,i);let g;const n=()=>{var r;if(!l)return;v=!1,m.forEach(t=>t(o()));const d=((r=e.onRehydrateStorage)==null?void 0:r.call(e,o()))||void 0;return I(l.getItem.bind(l))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var u;return g=e.merge(t,(u=o())!=null?u:f),s(g,!0),p()}).then(()=>{d==null||d(g,void 0),v=!0,h.forEach(t=>t(g))}).catch(t=>{d==null||d(void 0,t)})};return i.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(l=r.getStorage())},clearStorage:()=>{l==null||l.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>n(),hasHydrated:()=>v,onHydrate:r=>(m.add(r),()=>{m.delete(r)}),onFinishHydration:r=>(h.add(r),()=>{h.delete(r)})},n(),g||f},b=(c,a)=>(s,o,i)=>{let e={storage:_(()=>localStorage),partialize:n=>n,version:0,merge:(n,r)=>({...r,...n}),...a},v=!1;const m=new Set,h=new Set;let l=e.storage;if(!l)return c((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...n)},o,i);const S=()=>{const n=e.partialize({...o()});return l.setItem(e.name,{state:n,version:e.version})},p=i.setState;i.setState=(n,r)=>{p(n,r),S()};const y=c((...n)=>{s(...n),S()},o,i);let f;const g=()=>{var n,r;if(!l)return;v=!1,m.forEach(t=>{var u;return t((u=o())!=null?u:y)});const d=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(n=o())!=null?n:y))||void 0;return I(l.getItem.bind(l))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var u;return f=e.merge(t,(u=o())!=null?u:y),s(f,!0),S()}).then(()=>{d==null||d(f,void 0),f=o(),v=!0,h.forEach(t=>t(f))}).catch(t=>{d==null||d(void 0,t)})};return i.persist={setOptions:n=>{e={...e,...n},n.storage&&(l=n.storage)},clearStorage:()=>{l==null||l.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>g(),hasHydrated:()=>v,onHydrate:n=>(m.add(n),()=>{m.delete(n)}),onFinishHydration:n=>(h.add(n),()=>{h.delete(n)})},e.skipHydration||g(),f||y},D=(c,a)=>"getStorage"in a||"serialize"in a||"deserialize"in a?w(c,a):b(c,a),z=D;function F(c){return{seed:c,player:{level:1,xp:0,gold:0,diamond:0,food:0},inventory:{currentMonsterIndex:0,items:{},monsters:[{id:"Angel",level:1,xp:0}]},currentGameEvent:void 0}}const E=()=>({data:F(Date.now())}),L=H(R(z((c,a)=>({...E(),reset:()=>{c(E())}}),{name:"game"})));export{F as c,L as u};
